#pragma kernel CSMain

// Variables set from C#
int resolution;
int grass_size;
float step_size;

float3 grass_scale;

Texture2D<float4> density_map;
float erode_radius;

// CHANGED: Use AppendStructuredBuffer. This works like a List.Add() 
// and will only store instances that actually exist.
AppendStructuredBuffer<float4x4> transform_buffer;

// Height data from the terrain generator
StructuredBuffer<float> height_buffer;

SamplerState linear_clamp;
SamplerState point_clamp;

// Simple pseudo-random function
float rand(float2 co)
{
    return frac(sin(dot(co.xy, float2(12.9898, 78.233))) * 43758.5453);
}

// Helper to build the transformation matrix
float4x4 CreateTransformMatrix(float3 position, float rotationY, float3 scale)
{
    float cosY = cos(rotationY);
    float sinY = sin(rotationY);

    // Construct 4x4 matrix with rotation around Y-axis
    return float4x4(
        scale.x * cosY,  0.0,             scale.x * sinY,  position.x,
        0.0,             scale.y,         0.0,             position.y,
        -scale.z * sinY, 0.0,             scale.z * cosY,  position.z,
        0.0,             0.0,             0.0,             1.0
    );
}

[numthreads(64, 1, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    // Bounds check
    uint totalInstances = (uint)(resolution * resolution);
    if (id.x >= totalInstances)
        return;

    // ========================================================================
    // STEP 1: Calculate Grid Position
    // ========================================================================
    
    // Determine x and z indices from the 1D thread ID
    int xIndex = id.x % resolution;
    int zIndex = id.x / resolution;

    // Calculate normalized position (0 to 1)
    float xNorm = (float)xIndex / (float)(resolution - 1);
    float zNorm = (float)zIndex / (float)(resolution - 1);
    
    // Generate a random seed based on grid position
    float2 seedPos = float2(xNorm, zNorm);
    float randomSeed = rand(seedPos);
    
    // Offset range (-0.5 to 0.5 of the step size)
    float jitterX = (randomSeed - 0.5) * step_size;
    float jitterZ = (rand(seedPos + 1.0) - 0.5) * step_size;

    // ========================================================================
    // STEP 3: Calculate World Position
    // ========================================================================
    
    float halfSize = grass_size * 0.5;
    
    float worldX = (xNorm * grass_size) - halfSize + jitterX;
    float worldZ = (zNorm * grass_size) - halfSize + jitterZ;
    
    float worldY = height_buffer[id.x];
    float3 worldPos = float3(worldX, worldY, worldZ);
    
    float2 localPos = worldPos.xz;
    float2 uv = (localPos + halfSize) / grass_size;
    
    // Sample density with linear for a smooth density read
    float density = density_map.SampleLevel(linear_clamp, uv, 0).r;

    if (density <= 0.1)
        return;

    // Erode white edges inward â€” use point sampler so bilinear blending at slope
    // boundaries doesn't cause interior erosion to be missed
    if (erode_radius > 0.0)
    {
        if (density_map.SampleLevel(point_clamp, uv + float2( erode_radius, 0.0), 0).r < 0.5) return;
        if (density_map.SampleLevel(point_clamp, uv + float2(-erode_radius, 0.0), 0).r < 0.5) return;
        if (density_map.SampleLevel(point_clamp, uv + float2(0.0,  erode_radius), 0).r < 0.5) return;
        if (density_map.SampleLevel(point_clamp, uv + float2(0.0, -erode_radius), 0).r < 0.5) return;
    }

    float rotation = randomSeed * 6.28318530718;  // 2 * PI
    
    // Varied scale based on density and randomness
    float baseHeight = 1.0 * density;
    float heightVariation = randomSeed * 0.5;
    float3 scale = float3(1.0, baseHeight + heightVariation, 1.0) * grass_scale;

    // ========================================================================
    // STEP 6: Append to Buffer
    // ========================================================================
    
    // CHANGED: Use .Append() instead of array indexing [id.x].
    // This pushes the matrix to the end of the compact list.
    transform_buffer.Append(CreateTransformMatrix(worldPos, rotation, scale));
}
